---
title: "Project 7: Difference-in-Differences and Synthetic Control"
output:
  pdf_document: default
  html_document: default
---


```{r, warning=FALSE}
# Install and load packages 
#if (!require("pacman")) install.packages("pacman")
#devtools::install_github("susanathey/MCPanel")
#install.packages("C:/Users/MACKGS~1/AppData/Local/Temp/RtmpiszvSs/filef4a06b5d5e78/MCPanel_0.0.tar.gz", repos = NULL, type = "source")

#devtools::install_github("ebenmichael/augsynth")
#install.packages("tinytex")
#tinytex::install_tinytex()

pacman::p_load(# Tidyverse packages including dplyr and ggplot2
               tidyverse,
               ggthemes,
               augsynth,
               gsynth)


library(dplyr)
library(augsynth)
library(ggplot2)
library(tidyr)
#library(MCPanel) # this worked once but I haven't been able to get it to work again. It also didn't change the outcome, so I'm giving up on it for now
library(lubridate)
library(knitr)


# set seed
set.seed(44)

# load data
medicaid_expansion <- read_csv('./data/medicaid_expansion.csv')
#medicaid_expansion <- read_csv("C:/git/Computational-Social-Science-Projects/Project 7/data/medicaid_expansion.csv")

```
```{r, warning=FALSE}
# # Set CRAN mirror first
# options(repos = c(CRAN = "https://cloud.r-project.org"))
# 
# # Then install packages
# if (!requireNamespace("tinytex", quietly = TRUE)) {
#   install.packages("tinytex")
# }
# 
# if (!requireNamespace("devtools", quietly = TRUE)) {
#   install.packages("devtools")
# }
# 
# if (!requireNamespace("multisynth", quietly = TRUE)) {
#   devtools::install_github("ebenmichael/multisynth")
# }
# 
# # Load required libraries
# library(multisynth)
```
# Introduction

For this project, you will explore the question of whether the Affordable Care Act increased health insurance coverage (or conversely, decreased the number of people who are uninsured). The ACA was passed in March 2010, but several of its provisions were phased in over a few years. The ACA instituted the "individual mandate" which required that all Americans must carry health insurance, or else suffer a tax penalty. There are four mechanisms for how the ACA aims to reduce the uninsured population:

- Require companies with more than 50 employees to provide health insurance.
- Build state-run healthcare markets ("exchanges") for individuals to purchase health insurance.
- Provide subsidies to middle income individuals and families who do not qualify for employer based coverage.
- Expand Medicaid to require that states grant eligibility to all citizens and legal residents earning up to 138\% of the federal poverty line. The federal government would initially pay 100\% of the costs of this expansion, and over a period of 5 years the burden would shift so the federal government would pay 90\% and the states would pay 10\%.

In 2012, the Supreme Court heard the landmark case NFIB v. Sebelius, which principally challenged the constitutionality of the law under the theory that Congress could not institute an individual mandate. The Supreme Court ultimately upheld the individual mandate under Congress's taxation power, but struck down the requirement that states must expand Medicaid as impermissible subordination of the states to the federal government. Subsequently, several states refused to expand Medicaid when the program began on January 1, 2014. This refusal created the "Medicaid coverage gap" where there are indivudals who earn too much to qualify for Medicaid under the old standards, but too little to qualify for the ACA subsidies targeted at middle-income individuals.

States that refused to expand Medicaid principally cited the cost as the primary factor. Critics pointed out however, that the decision not to expand primarily broke down along partisan lines. In the years since the initial expansion, several states have opted into the program, either because of a change in the governing party, or because voters directly approved expansion via a ballot initiative.

You will explore the question of whether Medicaid expansion reduced the uninsured population in the U.S. in the 7 years since it went into effect. To address this question, you will use difference-in-differences estimation, and synthetic control.

# Data

The dataset you will work with has been assembled from a few different sources about Medicaid. The key variables are:

- **State**: Full name of state
- **Medicaid Expansion Adoption**: Date that the state adopted the Medicaid expansion, if it did so.
- **Year**: Year of observation.
- **Uninsured rate**: State uninsured rate in that year.

# Exploratory Data Analysis

Create plots and provide 1-2 sentence analyses to answer the following questions:

- Which states had the highest uninsured rates prior to 2014? The lowest?

Texas had the highest single uninsured rate, and Nevada had the highest average uninsured rate across that time. Lowest were Massachusetts, Hawaii, and Vermont, which is not surprising. 

- Which states were home to most uninsured Americans prior to 2014? 
Looks like California and Texas, which makes sense because of population. Florida is third,and New York is fourth. California had the highest average total over the pre-2014 time period.


- How about in the last year in the data set? 
In the last year, 2020, Texas has surpassed California (but CA is still 2nd). Florida and Georgia are still up there but New York has dropped down to fifth or sixth.


**Note**: 2010 state population is provided as a variable to answer this question. In an actual study you would likely use population estimates over time, but to simplify you can assume these numbers stay about the same.

```{r, warning=FALSE}
# highest and lowest uninsured rates

medicaid_expansion_to_2014 <- medicaid_expansion %>%
  filter(year >= 2008, year < 2014)

##nope
ggplot(medicaid_expansion_to_2014, aes(x = year, y = uninsured_rate, group = State, color = State)) +
  geom_line() +
  labs(title = "Uninsured Rate by State (2008–2013)",
       x = "Year",
       y = "Uninsured Rate (%)") +
  theme_minimal()

#messy but effective
ggplot(medicaid_expansion_to_2014, aes(x = year, y = uninsured_rate, group = State)) +
  geom_line(alpha = 0.7) +  # Lines, slightly transparent
  geom_text(data = medicaid_expansion_to_2014 %>% filter(year == 2013),
            aes(label = State),
            hjust = 0, vjust = 0.5, size = 2) +  # Labels at the end of lines
  labs(title = "Uninsured Rate by State (2008–2014)",
       x = "Year",
       y = "Uninsured Rate (%)") +
  theme_minimal() +
  theme(legend.position = "none") +
  xlim(2008, 2014)
```

```{r, warning=FALSE}
##trying something else -- highest by average across 2008-2014
state_summary <- medicaid_expansion_to_2014 %>%
  group_by(State) %>%
  summarize(avg_uninsured_rate = mean(uninsured_rate, na.rm = TRUE)) %>%
  arrange(desc(avg_uninsured_rate))

highest_state <- state_summary$State[1]
lowest_state <- state_summary$State[nrow(state_summary)]

#same viz, just highlighting those ones
ggplot(medicaid_expansion_to_2014, aes(x = year, y = uninsured_rate, group = State)) +
  geom_line(aes(color = State %in% c(highest_state, lowest_state)), linewidth = 1) +
  scale_color_manual(values = c("gray", "red")) + # Highlight selected states in red
  geom_text(data = medicaid_expansion_to_2014 %>% 
              filter(State %in% c(highest_state, lowest_state), year == 2013),
            aes(label = State),
            hjust = -0.1, size = 3) +
  labs(title = "Uninsured Rate by State (2008–2013)",
       subtitle = paste("Highlighting:", highest_state, "(highest) and", lowest_state, "(lowest)"),
       x = "Year",
       y = "Uninsured Rate (%)",
       color = "Highlighted State") +
  theme_minimal() +
  theme(legend.position = "none") # Remove legend if you want it cleaner



```

```{r, warning=FALSE}
# most uninsured Americans prior to 2014
medicaid_expansion_uninsured <- medicaid_expansion %>%
  mutate(uninsured_total = (uninsured_rate / 100) * population) %>%
  filter(year >= 2008, year < 2014)

ggplot(medicaid_expansion_uninsured, aes(x = year, y = uninsured_total, group = State)) +
  geom_line(alpha = 0.7) +  # Lines, slightly transparent
  geom_text(data = medicaid_expansion_uninsured %>% filter(year == 2013),
            aes(label = State),
            hjust = 0, vjust = 0.5, size = 2) +  # Labels at the end of lines
  labs(title = "Total Uninsured by State (2008–2013)",
       x = "Year",
       y = "Uninsured Total") +
  theme_minimal() +
  theme(legend.position = "none") +
  xlim(2008, 2014)

```

```{r, warning=FALSE}
#Average
state_summary_uninsured <- medicaid_expansion_uninsured %>%
  group_by(State) %>%
  summarize(avg_uninsured_total = mean(uninsured_total, na.rm = TRUE)) %>%
  arrange(desc(avg_uninsured_total))

highest_state_uninsured <- state_summary_uninsured$State[1]
lowest_state_uninsured <- state_summary_uninsured$State[nrow(state_summary_uninsured)]

ggplot(medicaid_expansion_uninsured, aes(x = year, y = uninsured_total, group = State)) +
  geom_line(color = "gray", size = 0.8) +  # All lines gray
  geom_line(data = medicaid_expansion_uninsured %>% filter(State %in% c(highest_state_uninsured, lowest_state_uninsured)),
            aes(color = State), size = 1.2) +  # Highlight important states
  geom_text(data = medicaid_expansion_uninsured %>% 
              filter(State %in% c(highest_state_uninsured, lowest_state_uninsured), year == 2013),
            aes(label = State),
            hjust = 0, vjust = 0.5, size = 3.5, fontface = "bold") +
  labs(title = "Number of Uninsured People by State (2008–2014)",
       subtitle = paste("Highlighting", highest_state_uninsured, "(highest) and", lowest_state_uninsured, "(lowest)"),
       x = "Year",
       y = "Total Uninsured",
       color = "State") +
  theme_minimal() +
  theme(legend.position = "none") +
  xlim(2008, 2014)


```


```{r, warning=FALSE}
# most uninsured Americans in 2020. DC is empty, it isn't really the most

medicaid_expansion_uninsured_2020 <- medicaid_expansion %>%
  mutate(uninsured_total = (uninsured_rate / 100) * population) %>%
  filter(year == 2020)

ggplot(medicaid_expansion_uninsured_2020, aes(x = reorder(State, uninsured_total), y = uninsured_total)) +
  geom_point(size = 3, color = "skyblue") +  # Dot plot
  geom_text(aes(label = scales::comma(uninsured_total)), vjust = -0.5, size = 3) +  # Labels on dots
  labs(title = "Total Uninsured by State (2020)",
       x = "State",
       y = "Uninsured Total") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_flip()  # Flip to make it horizontal for better readability


```

# Difference-in-Differences Estimation

## Estimate Model

Do the following:

- Choose a state that adopted the Medicaid expansion on January 1, 2014 and a state that did not. **Hint**: Do not pick Massachusetts as it passed a universal healthcare law in 2006, and also avoid picking a state that adopted the Medicaid expansion between 2014 and 2015.

```{r, warning=FALSE}
#set of states that expanded on the date of interest
expanded_on_dof <- medicaid_expansion %>%
  filter(Date_Adopted == as.Date("2014-01-01")) %>%
  distinct(State)

#Somehow took forever just to figure out how to see them all at once
# print(expanded_on_dof)
# print(expanded_on_dof, n = 30)
# view(expanded_on_dof)
print(expanded_on_dof$State)
```

```{r, warning=FALSE}
# set of states that didn't expand
not_expanded <- medicaid_expansion %>%
  filter(is.na(Date_Adopted)) %>%
  distinct(State)

print(not_expanded$State)
```
I'm going to start off using Kansas (didn't expand) and Arkansas (expanded on 1/1/2014), see how they look.

- Assess the parallel trends assumption for your choices using a plot. If you are not satisfied that the assumption has been met, pick another state and try again (but detail the states you tried).

Kansas and Arkansas are looking pretty good, especially between 2012 and 2013. Going to try a few more combos for fun

```{r, warning=FALSE}
# Parallel Trends plot: Arkansas and Kansas -- pretty good!
# Just Kansas and Arkansas
states_to_compare <- medicaid_expansion %>%
  filter(State %in% c("Kansas", "Arkansas"),
         year >= 2008, year < 2014)  # Pre-treatment years

ggplot(states_to_compare, aes(x = year, y = uninsured_rate, color = State)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = "Uninsured Rate: Kansas vs Arkansas (2008–2014)",
       x = "Year",
       y = "Uninsured Rate (%)",
       color = "State") +
  theme_minimal()


```



```{r, warning=FALSE}
# Parallel Trends plot: California and Texas: definitely not, terrible choices
states_to_compare <- medicaid_expansion %>%
  filter(State %in% c("Texas", "California"),
         year >= 2008, year < 2014)  # Pre-treatment years

ggplot(states_to_compare, aes(x = year, y = uninsured_rate, color = State)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = "Uninsured Rate: CA vs TX (2008–2014)",
       x = "Year",
       y = "Uninsured Rate (%)",
       color = "State") +
  theme_minimal()

```
```{r, warning=FALSE}
# Parallel Trends plot: Ohio and Missouri: also fairly poor trend match
states_to_compare <- medicaid_expansion %>%
  filter(State %in% c("Missouri", "Ohio"),
         year >= 2008, year < 2014)  # Pre-treatment years

ggplot(states_to_compare, aes(x = year, y = uninsured_rate, color = State)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = "Uninsured Rate: OH vs MS (2008–2014)",
       x = "Year",
       y = "Uninsured Rate (%)",
       color = "State") +
  theme_minimal()

```

- Estimates a difference-in-differences estimate of the effect of the Medicaid expansion on the uninsured share of the population. You may follow the lab example where we estimate the differences in one pre-treatment and one post-treatment period, or take an average of the pre-treatment and post-treatment outcomes



```{r, warning=FALSE}
# Difference-in-Differences estimation

# DiD for: Kansas-Arkansas. trying the point in time/subtraction thing
# ----------------------------------------------------------------
# create a dataset for Kansas and Arkansas
states_of_int <- 
  medicaid_expansion %>%
  filter(State %in% c("Kansas","Arkansas")) %>%
  filter(between(year, 2012, 2015)) #I don't think I need this actually? Also -- using "between", is there a way to not include the boundaries (like in the filter year > 2014 that I was doing before? 
  glimpse(states_of_int)

# pre-treatment difference
# ----------
pre_diff <- 
  states_of_int %>%
  # filter out only the quarter we want
  filter(year == 2012) %>%
  # subset to select only vars we want
  select(State, 
         uninsured_rate) %>%
  # make the data wide
  pivot_wider(names_from = State, 
              values_from = uninsured_rate) %>%
  # subtract to make calculation
  summarise(Kansas - Arkansas)
  glimpse(pre_diff)
  
# post-treatment difference
# ----------
post_diff <- 
  states_of_int %>%
  # filter out only the quarter we want
  filter(year == 2015) %>%
  # subset to select only vars we want
  select(State, 
         uninsured_rate) %>%
  # make the data wide
  pivot_wider(names_from = State, 
              values_from = uninsured_rate) %>%
  # subtract to make calculation
  summarise(Kansas - Arkansas)
  glimpse(post_diff)

# diff-in-diffs
# ----------
diff_in_diffs <- post_diff - pre_diff
diff_in_diffs


```
Looks like if this is true, the expansion resulted in a 3.6% decrease in the uninsured population between 2012 and 2015.

## 1. Discussion Questions

- Card/Krueger's original piece utilized the fact that towns on either side of the Delaware river are likely to be quite similar to one another in terms of demographics, economics, etc. Why is that intuition harder to replicate with this data?
- **Answer**: Card and Krueger compared places in NJ and PA, on either side of the Delaware River; the small populations and close geographies meant that demographics, economies, and culture, etc, were very similar. This helps with the parallel trends assumption, because you can more confidently say that any observed differences were due to the policy change only (in this case minimum wage), and not other factors. We, on the other hand, are comparing entire states -- larger, necessarily more diverse in terms of demographics, healthcare quality and availability, the economy, etc. Picking culturally similar states in the middle of the country helps but lots of things other than the expansion could actually be affecting the uninsured rates.

- What are the strengths and weaknesses of using the parallel trends assumption in difference-in-differences estimates?
- **Answer**: Strengths: 
1. You can (attempt to) estimate causal effects without controlling for every possible confounder, since supposedly DiD controls for changes over time and automatically adjusts for differences between groups. 
2. DiD is easy to implement and also to explain -- simple and intuitive. 

Weakness: 
I don't think there are actually any solid tests for the parallel trends assumption? At least in class we've only just assessed it visually. And that might feel like you're on kind of shaky ground because if you're off, and the groups in question were actually not on the same trajectories before the treatment, your conclusions are pretty much useless. 

# Synthetic Control

Estimate Synthetic Control

Although several states did not expand Medicaid on January 1, 2014, many did later on. In some cases, a Democratic governor was elected and pushed for a state budget that included the Medicaid expansion, whereas in others voters approved expansion via a ballot initiative. The 2018 election was a watershed moment where several Republican-leaning states elected Democratic governors and approved Medicaid expansion. In cases with a ballot initiative, the state legislature and governor still must implement the results via legislation. For instance, Idaho voters approved a Medicaid expansion in the 2018 election, but it was not implemented in the state budget until late 2019, with enrollment beginning in 2020.

Do the following:

- Choose a state that adopted the Medicaid expansion after January 1, 2014. Construct a non-augmented synthetic control and plot the results (both pre-treatment fit and post-treatment differences). Also report the average ATT and L2 imbalance.

```{r, warning=FALSE}
#looking at my options
late_expanders <- medicaid_expansion %>%
  filter(Date_Adopted > as.Date("2015-01-01")) %>%
  distinct(State, Date_Adopted)

print(late_expanders)

#want to pick a state with an average population, Louisiana is a good bet
medicaid_expansion_late <- medicaid_expansion %>%
  filter(State %in% late_expanders$State) %>% 
  filter(year == 2016)

print(medicaid_expansion_late)

```

-Construct a non-augmented synthetic control and plot the results (both pre-treatment fit and post-treatment differences). Also report the average ATT and L2 imbalance.

```{r, warning=FALSE}
# non-augmented synthetic control using Louisiana



#define a treatment var. Uisng 2017 as first true post-treatment year since the adoption was mid-2016
medicaid_expansion <- medicaid_expansion %>%
  mutate(treatment = if_else(State == "Louisiana" & year >= 2017, 1, 0))

# Run non-augmented synthetic control for Louisiana
syn_louisiana <- augsynth(
  uninsured_rate ~ treatment,   # outcome ~ treatment indicator
  unit = State,                 # unit of analysis
  time = year,                  # time variable
  t_int = 2017,
  data = medicaid_expansion,   # your dataset
  unit_name = "Louisiana",     # treated unit
  progfunc = "None",           # no augmentation (use "ridge" for augmented)
  scm = TRUE                   # use synthetic control method
)

# # View summary of results

# this is not working not sure why
# summary(syn_louisiana)
# 
# 
# att <- summary(syn_louisiana)$att.avg
# imbalance <- summary(syn_louisiana)$imbalance
# 
# print(att)
# print(imbalance)

syn_summary <- summary(syn_louisiana)
glimpse(syn_summary)

att <- syn_summary$average_att$Estimate
pval <- syn_summary$average_att$p_val
imbalance <- syn_summary$l2_imbalance
improvement <- 1 - (syn_summary$scaled_l2_imbalance / syn_summary$l2_imbalance)

print(att)
print(pval)
print(imbalance)
print(improvement)
```
ATT of -0.02567633 shows that Louisiana's uninsured rate dropped by 2.57 more percentage points on average than the synthetic control post-treatment.

the p-value of 0.284 isn't great, a p value of under 0.05 is a normal level of significance so this is pretty large. 

Imbalance:	0.0052, low imbalance, I think this just means that the pre-treatment fit is good.

Improvement: The internet says to test for this too.	It's -8.37%. I don't totally understand this to be honest, but I think negative is not good, because it means I could have just averaged all the other states instead of doing all this synthetic control modeling and it would have been better.  


```{r, warning=FALSE}

str(syn_louisiana) # what even is the data now
head(syn_louisiana)

# Extract time and outcome values
#time_vals <- as.integer(colnames(syn_louisiana$data$X))  # Tried to get the years from column names
#needed to hard code it bc it was too hard to extract the years
time_vals <- 2008:2020 
#time_vals <- syn_louisiana$data$synth_data$Y0plot[,1]  # Assuming time is the same for all units?
actual_vals <- syn_louisiana$data$synth_data$Y1plot[,1]  # treated LA outcome
synthetic_vals <- syn_louisiana$data$synth_data$Y0plot[,1]  # synthetic control outcome


# Check the extracted values
head(time_vals)
head(actual_vals)
print(synthetic_vals)

# Create a data frame with columns for Year, Actual, and Synthetic
outcome_df <- data.frame(
  Year = time_vals,
  Actual = actual_vals,
  Synthetic = synthetic_vals
)


#is this working
head(outcome_df)

```

```{r, warning=FALSE}
summary(outcome_df)
```

```{r, warning=FALSE}
#plots

#pre-treatment plot


# Convert to long format for ggplot
# Make sure the reshaping process is working correctly
outcome_long <- pivot_longer(outcome_df, 
                             cols = c("Actual", "Synthetic"), 
                             names_to = "Type", 
                             values_to = "UninsuredRate")

# Check the reshaped data frame
head(outcome_long)

# Check
head(outcome_long)
```

```{r, warning=FALSE}
# Create the plot
#pre-treatment

ggplot(outcome_long, aes(x = Year, y = UninsuredRate, color = Type, linetype = Type)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = syn_louisiana$t_int, linetype = "dashed", color = "gray40") +  # Treatment time
  labs(
    title = "Actual vs Synthetic Uninsured Rate in Louisiana",
    x = "Year",
    y = "Uninsured Rate",
    color = "Legend",
    linetype = "Legend"
  ) +
  theme_minimal()


```
Ok so this plot should be showing a line for actual treated unit outcome (red) (e.g., LA's uninsured rate) and one for the synthetic control estimate (blue, dotted). They are pretty close right before treatment and then after treatment they diverge, more specifically, the "actual" line dips, implying that maybe the treatment works to reduce uninsured rates. 

```{r, warning=FALSE}
#post-treatment
library(ggplot2)

# Extract ATT time-series
att_df <- summary(syn_louisiana)$att

ggplot(att_df, aes(x = Time, y = Estimate)) +
  geom_line(color = "darkred", size = 1.2) +
  geom_vline(xintercept = summary(syn_louisiana)$t_int, linetype = "dashed", color = "gray40") +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  labs(
    title = "Post-Treatment Differences: Louisiana vs Synthetic Control",
    subtitle = "Estimated ATT (Treated - Synthetic) Over Time",
    x = "Year",
    y = "ATT (Uninsured Rate Difference)"
  ) +
  theme_minimal()

```
This plot is supposed to show the difference between the actual and synthetic outcomes. Makes sense that the difference should be about zero until the point of treatment, which we've classified at 2017. 

- Re-run the same analysis but this time use an augmentation (default choices are Ridge, Matrix Completion, and GSynth). Create the same plot and report the average ATT and L2 imbalance.

```{r, warning=FALSE}
summary(medicaid_expansion$uninsured_rate)
summary(medicaid_expansion$treatment)
summary(medicaid_expansion$population)

medicaid_expansion <- medicaid_expansion %>% 
  filter(!is.na(uninsured_rate), !is.na(treatment), !is.na(population))
```


```{r, warning=FALSE}
# augmented synthetic control

#define a treatment var. Uisng 2017 as first true post-treatment year since the adoption was mid-2016
medicaid_expansion <- medicaid_expansion %>%
  mutate(treatment = if_else(State == "Louisiana" & year >= 2017, 1, 0))

# Run augmented synthetic control for Louisiana
# syn_louisiana <- augsynth(
#   uninsured_rate ~ treatment,   # outcome ~ treatment indicator
#   unit = State,                 # unit of analysis
#   time = year,                  # time variable
#   t_int = 2017,
#   data = medicaid_expansion,   # your dataset
#   unit_name = "Louisiana",     # treated unit
#   progfunc = "MCP",           # using matrix completion bc the internet says ridge won't do anything without covariates and we kind of don't have those, other than population I guess. I'll try adding population as a covariate
#   scm = TRUE                   # use synthetic control method
# )


#Ok I tried running the ridge a bunch of ways and it's still identical to non-augmented. going to try "MCP" above, if it's still identical I'm giving up
syn_louisiana <- augsynth(
  form = uninsured_rate ~ treatment | population,  # outcome ~ treatment + covariate
  unit = State,                                    # unit identifier
  time = year,                                     # time variable
  t_int = 2017,                                    # first treated period
  data = medicaid_expansion,                       # data
  unit_name = "Louisiana",                         # treated unit
  progfunc = "ridge",                              # ridge regression for augmentation
  scm = TRUE                                       # use synthetic control method
)



# # View summary of results

# this is not working not sure why
# summary(syn_louisiana)
# 
# 
# att <- summary(syn_louisiana)$att.avg
# imbalance <- summary(syn_louisiana)$imbalance
# 
# print(att)
# print(imbalance)

syn_summary <- summary(syn_louisiana)
glimpse(syn_summary)

att <- syn_summary$average_att$Estimate
pval <- syn_summary$average_att$p_val
imbalance <- syn_summary$l2_imbalance
improvement <- 1 - (syn_summary$scaled_l2_imbalance / syn_summary$l2_imbalance)

print(att)
print(pval)
print(imbalance)
print(improvement)

```
```{r, warning=FALSE}
str(syn_louisiana) # ridge data 
head(syn_louisiana)

# Extract time and outcome values
#time_vals <- as.integer(colnames(syn_louisiana$data$X))  # Tried to get the years from column names
#needed to hard code it bc it was too hard to extract the years
time_vals <- 2008:2020 
#time_vals <- syn_louisiana$data$synth_data$Y0plot[,1]  # Assuming time is the same for all units?
actual_vals <- syn_louisiana$data$synth_data$Y1plot[,1]  # treated LA outcome
synthetic_vals <- syn_louisiana$data$synth_data$Y0plot[,1]  # synthetic control outcome


# Check the extracted values
head(time_vals)
head(actual_vals)
print(synthetic_vals)

# Create a data frame with columns for Year, Actual, and Synthetic
outcome_df <- data.frame(
  Year = time_vals,
  Actual = actual_vals,
  Synthetic = synthetic_vals
)


#is this working
head(outcome_df)


# Convert to long format for ggplot
# Make sure the reshaping process is working correctly
outcome_long_ridge <- pivot_longer(outcome_df, 
                             cols = c("Actual", "Synthetic"), 
                             names_to = "Type", 
                             values_to = "UninsuredRate")

# Check the reshaped data frame
view(outcome_long_ridge)
view(outcome_long)


```


```{r, warning=FALSE}
# Create the plot
#pre-treatment

ggplot(outcome_long, aes(x = Year, y = UninsuredRate, color = Type, linetype = Type)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = syn_louisiana$t_int, linetype = "dashed", color = "gray40") +  # Treatment time
  labs(
    title = "Actual vs Synthetic Uninsured Rate in Louisiana",
    x = "Year",
    y = "Uninsured Rate",
    color = "Legend",
    linetype = "Legend"
  ) +
  theme_minimal()


```

```{r, warning=FALSE}
# Extract ATT time-series
att_df <- summary(syn_louisiana)$att

ggplot(att_df, aes(x = Time, y = Estimate)) +
  geom_line(color = "darkred", size = 1.2) +
  geom_vline(xintercept = summary(syn_louisiana)$t_int, linetype = "dashed", color = "gray40") +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  labs(
    title = "Post-Treatment Differences: Louisiana vs Synthetic Control",
    subtitle = "Estimated ATT (Treated - Synthetic) Over Time",
    x = "Year",
    y = "ATT (Uninsured Rate Difference)"
  ) +
  theme_minimal()
```

- Plot barplots to visualize the weights of the donors.


```{r, warning=FALSE}
# barplots of weights
donor_weights <- coef(syn_louisiana)$weights

weights_df <- tibble(
  State = names(donor_weights),
  Weight = as.numeric(donor_weights)
)

summary(syn_louisiana)


 print(names(donor_weights))
 print(coef(syn_louisiana)$weights)
 print(syn_louisiana$weights)
 
 
 weights_df <- as.data.frame(syn_louisiana$weights) %>%
  rownames_to_column(var = "State") %>%
  rename(Weight = V1) %>%
  filter(abs(Weight) > 1e-5)
 glimpse(weights_df)



ggplot(weights_df, aes(x = reorder(State, Weight), y = Weight)) +
  geom_bar(stat = "identity", fill = "dodgerblue") +
  coord_flip() +
  labs(
    title = "Donor Weights for Synthetic Louisiana",
    x = "Donor State",
    y = "Weight"
  ) +
  theme_minimal()

```

**HINT**: Is there any preprocessing you need to do before you allow the program to automatically find weights for donor states?

I needed to check for NAs. Should I have standardized? I don't know. I didn't end up using any covariates, so I guess that didn't really matter. I had to create a treatment variable. Not sure what else I was supposed to do. 

## 2. Discussion Questions


- What are the advantages and disadvantages of synthetic control compared to difference-in-differences estimators?
- **Answer** They are kind of similar, but DiD is easier to explain and less computationally expensive than synthetic control (SC). DiD depends so heavily on the parallel trends assumption, so SC is perhaps more robust in certain cases. SC and DiD are both pretty easy to convey in plots, but maybe SC is a little bit easier to understand visually? In general DiD is simpler, faster, and easier but also requires strong assumptions. 

- One of the benefits of synthetic control is that the weights are bounded between [0,1] and the weights must sum to 1. Augmentation might relax this assumption by allowing for negative weights. Does this create an interpretation problem, and how should we balance this consideration against the improvements augmentation offers in terms of imbalance in the pre-treatment period?
- **Answer**: Allowing negative weights definitely causes a loss of clear interpretation. The balance has got to be case-specific, I think -- it’s going to always be a tradeoff between better fit (and therefore better causal estimates) versus a less intuitive interpretation. So it depends what's more important for the study at hand -- easily explainable results, or minimized bias. 

# Staggered Adoption Synthetic Control

## Estimate Multisynth

Do the following:

- Estimate a multisynth model that treats each state individually. Choose a fraction of states that you can fit on a plot and examine their treatment effects.

```{r, warning=FALSE}
# multisynth model states

#starting fresh with the data 663 
medicaid_expansion <- read_csv('./data/medicaid_expansion.csv')
glimpse(medicaid_expansion)


#new treatment var
medicaid_expansion$expansion_year <- year(medicaid_expansion$Date_Adopted)
medicaid_expansion <- medicaid_expansion %>%
  mutate(treatment = if_else(year >= expansion_year, 1, 0))
medicaid_expansion$treatment <- ifelse(is.na(medicaid_expansion$treatment), 0, medicaid_expansion$treatment)
glimpse(medicaid_expansion)
medicaid_expansion <- medicaid_expansion %>%
  mutate(treatment = replace_na(treatment, 0))

#debugging. this is not working 
medicaid_expansion <- medicaid_expansion %>%
  filter(!is.na(State), !is.na(treatment))
glimpse(medicaid_expansion)

#is it NAs? var formats??
medicaid_expansion$State <- as.factor(medicaid_expansion$State)
medicaid_expansion$year <- as.numeric(medicaid_expansion$year)
medicaid_expansion$expansion_year <- as.numeric(medicaid_expansion$expansion_year)
sum(is.na(medicaid_expansion$State))  
sum(is.na(medicaid_expansion$treatment)) 
table(medicaid_expansion$treatment) 
medicaid_expansion %>%
  filter(is.na(State)) %>%
  nrow()
medicaid_expansion %>%
  group_by(State) %>%
  summarise(ever_treated = any(treatment == 1)) %>%
  count(ever_treated)
sum(is.na(medicaid_expansion$uninsured_rate))
str(medicaid_expansion)
table(medicaid_expansion$treatment, useNA = "always")

#the data appears to make sense....
medicaid_expansion %>%
  group_by(State) %>%
  summarise(min_year = min(year), max_year = max(year)) %>%
  arrange(min_year)

#the data appears to make sense...
ggplot(medicaid_expansion, aes(x = year, y = reorder(State, year), color = factor(treatment))) +
  geom_point() +
  labs(color = "Treatment", y = "State", x = "Year") +
  theme_minimal()

##what is happening with trt_time
# medicaid_expansion %>%
#   group_by(State) %>%
#   summarise(
#     trt_time = ifelse(any(treatment == 1),
#                       min(year[treatment == 1]),
#                       Inf)  # Inf for control states
#   ) %>%
#   filter(is.na(trt_time))

#All the control states have NA for trt_time, I don't know why

# table(medicaid_expansion$treatment, useNA = "always")
# length(unique(medicaid_expansion$State))


##why is this still not working? Might have to drop some states
good_states <- medicaid_expansion %>%
  group_by(State) %>%
  summarise(has_treatment_info = any(treatment == 1) | all(treatment == 0)) %>%
  filter(has_treatment_info) %>%
  pull(State)
medicaid_expansion <- medicaid_expansion %>%
  filter(State %in% good_states)

table(medicaid_expansion$treatment, useNA = "always")
length(unique(medicaid_expansion$State))

##trt_time is the problem for sure, my control states are NA and not Inf, going to do this manually
# trt_times <- medicaid_expansion %>%
#   group_by(State) %>%
#   summarise(
#     trt_time = ifelse(any(treatment == 1),
#                       min(year[treatment == 1]),
#                       Inf)
#   )

# medicaid_expansion <- medicaid_expansion %>%
#   left_join(trt_times, by = "State")

table(medicaid_expansion$trt_time, useNA = "always")

# medicaid_expansion <- medicaid_expansion %>%
#   mutate(trt_time = replace_na(trt_time, Inf)) 

summary(medicaid_expansion$trt_time)
table(medicaid_expansion$State)

#is expansion_year the problem?
medicaid_expansion %>% select(State, year, expansion_year) %>% head(10)

expansion_info <- medicaid_expansion %>%
  group_by(State) %>%
  summarize(expansion_year = unique(na.omit(expansion_year))[1], .groups = "drop")

medicaid_expansion <- medicaid_expansion %>%
  left_join(expansion_info, by = "State")

glimpse(medicaid_expansion)

#class(trt_time)
str(medicaid_expansion)


```

```{r, warning=FALSE}
# Trying a smaller subset

# 
# subset_data %>%
#   group_by(State) %>%
#   summarise(
#     min_year = min(year),
#     max_year = max(year),
#     first_treatment_year = min(year[treatment == 1], na.rm = TRUE),
#     trt_time = unique(trt_time)  # See the trt_time values
#   )
# 
# subset_data <- medicaid_expansion %>% filter(State == "Louisiana")  # Replace with one state


##I've tried these models every way I can think of and I'm getting the same error.
# 
# multi_synth_model <- multisynth(
#   outcome = "uninsured_rate",
#   form = as.formula("uninsured_rate ~ 1"),
#   unit = "State",
#   time = "year",
#   treatment = "treatment",
#   t_int = 2017,
#   data = subset_data,
#   scm = TRUE,
#   progfunc = "none"
# )
# 
# multi_syn_model <- multisynth(uninsured_rate ~ treatment, 
#                         State,                        # unit
#                         year,                         # time
#                         subset_data,                   # data
#                         trt_time = "expansion_year"
#                         #n_leads = 10 #for staggered adoption
#                         ) 
```

```{r, warning=FALSE}

#more attempts
# 
# multi_synth_model <- multisynth(
#   outcome = "uninsured_rate",
#   form = as.formula("uninsured_rate ~ 1"),
#   unit = "State",
#   time = "year",
#   treatment = "treatment",
#   t_int = 2017,
#   data = medicaid_expansion,
#   scm = TRUE,
#   progfunc = "none"
# )
# 
# multi_syn_model <- multisynth(
#   uninsured_rate ~ treatment,             # Outcome variable and treatment formula
#   unit = "State",                          # Unit of analysis
#   time = "year",                           # Time variable
#   treatment = "treatment",                 # Treatment indicator (just to be explicit)
#   data = medicaid_expansion,               # Cleaned dataset
#   n_leads = 7                              # For staggered adoption
# )
# 
# 
# multi_syn_model <- multisynth(
#   form = uninsured_rate ~ treatment,  # Outcome and treatment formula
#   unit = State,                     # Unit column
#   time = year,                      # Time column
#   data = medicaid_expansion,          # Dataset
#   n_leads = 7                         # Number of post-treatment periods
# )
```

```{r, warning=FALSE}

##Ok I was using quotes and I shouldn't have been. Oy

# medicaid_expansion <- medicaid_expansion %>%
#   mutate(treatment = ifelse(!is.na(expansion_year) & year >= expansion_year, 1, 0))
# view(medicaid_expansion)

# Now run multisynth
ms_result <- multisynth(
  uninsured_rate ~ treatment, # Outcome ~ treatment
  unit = State,               # Unit identifier
  time = year,                # Time variable
  data = medicaid_expansion   # Dataset
)

# summary of results
summary(ms_result)

# Plot results
plot(ms_result)


```

- Estimate a multisynth model using time cohorts. For the purpose of this exercise, you can simplify the treatment time so that states that adopted Medicaid expansion within the same year (i.e. all states that adopted epxansion in 2016) count for the same cohort. Plot the treatment effects for these time cohorts.

```{r, warning=FALSE}
# multisynth model time cohorts

# Run multisynth model
multi_syn_model <- multisynth(uninsured_rate ~ treatment, 
                        State,                        # unit
                        year,                         # time
                        medicaid_expansion,            # data
                        n_leads = 7,                    #for staggered adoption
                        time_cohort = TRUE
                        ) 

# summary of results
summary(ms_result)

# Plot results
plot(ms_result)

```

```{r, warning=FALSE}
##Repeating with just a subset, as requested
states_of_interest <- c("California", "New York", "Texas", "Florida", "Ohio")

subset_data <- medicaid_expansion %>%
  filter(State %in% states_of_interest)

# Run multisynth on subset
subset_ms <- multisynth(
  uninsured_rate ~ treatment,
  unit = State,
  time = year,
  data = subset_data
)

# Plot subset results
plot(subset_ms)

```


## 3. Discussion Questions

- One feature of Medicaid is that it is jointly administered by the federal government and the states, and states have some flexibility in how they implement Medicaid. For example, during the Trump administration, several states applied for waivers where they could add work requirements to the eligibility standards (i.e. an individual needed to work for 80 hours/month to qualify for Medicaid). Given these differences, do you see evidence for the idea that different states had different treatment effect sizes?
- **Answer**: So if they are given 1115/1915b waivers, states can adapt different conditions to MediCaid -- the work requirements are adopted in some states, in others additional services are provided (like tenancy support in CA). In this context, that would mean that the expansions are being implemented heterogenously, and the way they are being implemented (rather than the expansion itself) might be impacting the takeup rate. So yes, it makes sense that different states would have different treatment effect sizes. 

- Do you see evidence for the idea that early adopters of Medicaid expansion enjoyed a larger decrease in the uninsured population?
- **Answer**: There's some evidence for that. The straight DiD between Kansas and Arkansas showed a 3.6% decrease for the early adopter. After that, I'm honestly not sure I did the analysis correctly -- I was struggling just to get things to run and I don't know why the non-augmented and augmented analyses looked the same, or why only a portion of my selected states showed up in the plot. 

# 4. General Discussion Questions

- Why are DiD and  synthetic control estimates well suited to studies of aggregated units like cities, states, countries, etc?
- **Answer**: DiD and SC are good for aggregated units like states because they work well with small numbers of treated units, observational settings (where policies aren't randomly assigned), and instances in which longitudinal data is available. These kinds of units also have abrupt policy changes (like the Medicaid expansion!) which works well for DiD and SC. And these methods use untreated units as controls, so they can take construct counter-factuals from the kind of data typically available at state/county/etc levels.

- What role does selection into treatment play in DiD/synthetic control versus regression discontinuity? When would we want to use either method?
- **Answer**: In DiD and SC, treatment isn’t random — we just assume that treated and control groups would’ve kept following similar trends if there was no treatment. If that assumption is false, the results can be biased. In regression discontinuity (RD), treatment depends on hitting a cutoff, so around that cutoff, it’s almost like random assignment. We should use DiD or SC when there are big treatment units (like states) and good pre-treatment trend data, and RD when there's some kind of more or less clear rule that dictates who gets treated.